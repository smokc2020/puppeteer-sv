// Gi·ªØ nguy√™n ph·∫ßn import v√† c·∫•u h√¨nh Express
import express from "express";
import puppeteer from "puppeteer";
import axios from "axios";
import fs from "fs";
import path from "path";
import { v4 as uuidv4 } from "uuid";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const app = express();
const port = 4000;

app.use(express.json());

const tempDir = path.resolve(__dirname, "temp");
if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);

function formatDriveLink(link) {
  const fileIdMatch = link.match(/(?:\/d\/|id=)([\w-]{25,})/);
  if (fileIdMatch && fileIdMatch[1]) {
    return `https://drive.google.com/uc?id=${fileIdMatch[1]}`;
  }
  return link;
}

async function downloadFileFromUrl(fileUrl) {
  const fileExt = path.extname(fileUrl.split("?")[0]) || ".jpg";
  const fileName = uuidv4() + fileExt;
  const filePath = path.resolve(tempDir, fileName);
  const writer = fs.createWriteStream(filePath);

  const response = await axios({
    method: "GET",
    url: fileUrl,
    responseType: "stream",
  });

  response.data.pipe(writer);

  return new Promise((resolve, reject) => {
    writer.on("finish", () => resolve(filePath));
    writer.on("error", reject);
  });
}

function extractIdsFromPostUrl(url) {
  try {
    if (!url) return { pageId: null, postId: null };
    const permalinkMatch = url.match(/permalink\.php\?story_fbid=([\w-]+)&id=(\d+)/);
    if (permalinkMatch) return { pageId: permalinkMatch[2], postId: permalinkMatch[1] };

    const postsMatch = url.match(/facebook\.com\/(\d+)\/posts\/([\w-]+)/);
    if (postsMatch) return { pageId: postsMatch[1], postId: postsMatch[2] };

    const pageNameMatch = url.match(/facebook\.com\/([^\/]+)\/posts\/([\w-]+)/);
    if (pageNameMatch) return { pageName: pageNameMatch[1], pageId: null, postId: pageNameMatch[2] };

    const photoMatch = url.match(/fbid=([\w-]+).*?id=(\d+)/);
    if (photoMatch) return { pageId: photoMatch[2], postId: photoMatch[1] };

    return { pageId: null, postId: null };
  } catch (error) {
    console.error("‚ùå L·ªói khi tr√≠ch xu·∫•t ID t·ª´ URL:", error);
    return { pageId: null, postId: null };
  }
}

app.post("/post-to-facebook", async (req, res) => {
  const { pages, content, images } = req.body;
  if (!pages || !content || !Array.isArray(pages)) {
    return res.status(400).json({ error: "Thi·∫øu th√¥ng tin ho·∫∑c pages kh√¥ng h·ª£p l·ªá!" });
  }

  const browser = await puppeteer.launch({
    executablePath: "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
    headless: false,
    userDataDir: "C:\\Users\\smokc\\AppData\\Local\\Google\\Chrome\\User Data\\1",
    args: [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-blink-features=AutomationControlled",
      "--lang=vi-VN",
      "--disable-gpu",
      "--disable-software-rasterizer",
      "--start-maximized",
      "--disable-extensions",
    ],
    slowMo: 50,
  });

  const page = await browser.newPage();
  await page.setViewport({ width: 1280, height: 720 });

  const resultList = [];

  try {
    // ƒê·∫ßu ti√™n, ƒëi ƒë·∫øn trang qu·∫£n l√Ω Facebook Pages
    console.log("üåê ƒêang truy c·∫≠p trang qu·∫£n l√Ω Facebook Pages...");
    await page.goto('https://www.facebook.com/pages/?category=your_pages&ref=bookmarks', { 
      waitUntil: "networkidle2",
      timeout: 30000
    });
    await new Promise(r => setTimeout(r, 3000));

    for (let i = 0; i < pages.length; i++) {
      const pageID = pages[i];
      console.log(`üîπ ƒêang chu·∫©n b·ªã ƒëƒÉng b√†i l√™n trang ID: ${pageID}`);
      
      // T√¨m v√† click v√†o n√∫t "Chuy·ªÉn" cho trang hi·ªán t·∫°i t·ª´ trang qu·∫£n l√Ω
      let switchClicked = false;
      
      try {
        // Ph∆∞∆°ng ph√°p t√¨m v√† click n√∫t "Chuy·ªÉn" b·∫±ng evaluate
        switchClicked = await page.evaluate((pageID) => {
          // T√¨m t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ ch·ª©a pageID
          const pageLinks = document.querySelectorAll(`a[href*="${pageID}"]`);
          
          for (const link of pageLinks) {
            // T√¨m container cha v√† n√∫t "Chuy·ªÉn" trong ƒë√≥
            let parent = link;
            
            // Di chuy·ªÉn l√™n t·ªëi ƒëa 5 c·∫•p cha
            for (let i = 0; i < 5; i++) {
              if (!parent) break;
              parent = parent.parentElement;
              
              // T√¨m n√∫t "Chuy·ªÉn" trong container n√†y
              const buttons = parent.querySelectorAll('div[role="button"]');
              for (const button of buttons) {
                if (button.textContent && button.textContent.includes('Chuy·ªÉn')) {
                  button.click();
                  return true;
                }
              }
            }
          }
          return false;
        }, pageID);
        
        if (switchClicked) {
          console.log(`‚úÖ ƒê√£ click v√†o n√∫t Chuy·ªÉn cho trang ID: ${pageID}`);
          // ƒê·ª£i l√¢u h∆°n ƒë·ªÉ chuy·ªÉn trang ho√†n to√†n
          await new Promise(r => setTimeout(r, 5000));
        }
      } catch (evalError) {
        console.log(`‚ö†Ô∏è L·ªói khi t√¨m n√∫t Chuy·ªÉn: ${evalError.message}`);
      }
      
      // N·∫øu kh√¥ng t√¨m th·∫•y n√∫t "Chuy·ªÉn", truy c·∫≠p tr·ª±c ti·∫øp URL trang
      if (!switchClicked) {
        console.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t Chuy·ªÉn, truy c·∫≠p tr·ª±c ti·∫øp...`);
        await page.goto(`https://www.facebook.com/profile.php?id=${pageID}`, { waitUntil: "networkidle2" });
        await new Promise(r => setTimeout(r, 3000));
        
        // T√¨m v√† nh·∫•n n√∫t "Chuy·ªÉn" n·∫øu c√≥ tr√™n trang
        try {
          const switchButtonExists = await page.$('div[aria-label="Chuy·ªÉn ngay"], div[role="button"][aria-label*="qu·∫£n tr·ªã vi√™n"]');
          if (switchButtonExists) {
            await switchButtonExists.click();
            await new Promise(r => setTimeout(r, 1000));
          }
        } catch (switchError) {
          console.log(`‚ö†Ô∏è L·ªói khi t√¨m n√∫t Chuy·ªÉn tr·ª±c ti·∫øp: ${switchError.message}`);
        }
      }

      // M·ªü h·ªôp so·∫°n b√†i vi·∫øt
      try {
        const openTextBoxExists = await page.$('::-p-text(B·∫°n ƒëang nghƒ©)');
        if (openTextBoxExists) {
          await openTextBoxExists.click();
          await new Promise(r => setTimeout(r, 1500));
        } else {
          console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y h·ªôp so·∫°n b√†i, th·ª≠ c√°ch kh√°c...");
          const altTextBoxExists = await page.$('::-p-text(B·∫°n ƒëang nghƒ©)');
          if (altTextBoxExists) {
            await altTextBoxExists.click();
            await new Promise(r => setTimeout(r, 1500));
          } else {
            console.log("‚ùå Kh√¥ng th·ªÉ m·ªü h·ªôp so·∫°n b√†i vi·∫øt cho trang n√†y");
            continue; // Chuy·ªÉn sang trang ti·∫øp theo
          }
        }
      } catch (textBoxError) {
        console.log(`‚ö†Ô∏è L·ªói khi m·ªü h·ªôp so·∫°n b√†i: ${textBoxError.message}`);
        continue; // Chuy·ªÉn sang trang ti·∫øp theo n·∫øu kh√¥ng m·ªü ƒë∆∞·ª£c h·ªôp so·∫°n b√†i
      }

      // Nh·∫≠p n·ªôi dung b√†i vi·∫øt
      await page.keyboard.type(content, { delay: 20 });
      await new Promise(r => setTimeout(r, 4000));

      // T·∫£i v√† ƒëƒÉng ·∫£nh n·∫øu c√≥
      if (images && images.length > 0) {
        const downloadedPaths = [];
        for (const rawUrl of images) {
          const formatted = formatDriveLink(rawUrl);
          const filePath = await downloadFileFromUrl(formatted);
          downloadedPaths.push(filePath);
        }

        try {
          const fileChooserPromise = page.waitForFileChooser();
          const uploadButtonExists = await page.$('::-p-text(Th√™m ·∫£nh/video)');
          if (uploadButtonExists) {
            await uploadButtonExists.click();
            const fileChooser = await fileChooserPromise;
            await fileChooser.accept(downloadedPaths);
            await new Promise(r => setTimeout(r, 5000));
          }

          // X√≥a file t·∫°m
          for (const path of downloadedPaths) {
            fs.unlink(path, () => {});
          }
        } catch (imageError) {
          console.log(`‚ö†Ô∏è L·ªói khi t·∫£i ·∫£nh: ${imageError.message}`);
        }
      }

      await new Promise(r => setTimeout(r, 2000));

      // Nh·∫•n n√∫t Ti·∫øp n·∫øu c√≥
      try {
        const continueButtonExists = await page.$('::-p-text(Ti·∫øp), ::-p-text(Next)');
        if (continueButtonExists) {
          await continueButtonExists.click();
          await new Promise(r => setTimeout(r, 2000));
        }
      } catch (e) {
        console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t Ti·∫øp");
      }

      // Nh·∫•n n√∫t ƒêƒÉng
      try {
        const postButtonExists = await page.$('div[aria-label="ƒêƒÉng"], div[role="button"][aria-label*="ƒêƒÉng"]');
        if (postButtonExists) {
          await postButtonExists.click();
          console.log(`‚úÖ ƒê√£ nh·∫•n n√∫t ƒêƒÉng`);
          await new Promise(r => setTimeout(r, 3000));
        } else {
          throw new Error("Kh√¥ng t√¨m th·∫•y n√∫t ƒêƒÉng");
        }
      } catch (e) {
        console.log("‚ùå Kh√¥ng t√¨m th·∫•y n√∫t ƒêƒÉng!");
        // Th·ª≠ d√πng Enter ƒë·ªÉ ƒëƒÉng b√†i
        await page.keyboard.press('Enter');
        console.log("‚ö†Ô∏è ƒê√£ th·ª≠ nh·∫•n Enter ƒë·ªÉ ƒëƒÉng b√†i");
        await new Promise(r => setTimeout(r, 3000));
      }

      // L·∫•y URL b√†i ƒëƒÉng
      let postUrl = null;
      try {
        await page.waitForSelector('a[href*="permalink.php?story_fbid="]', { timeout: 8000 }).catch(() => {});
        
        // S·ª≠ d·ª•ng page.$ thay v√¨ page.locator
        const postLinks = await page.$$('a[href*="permalink.php?story_fbid="]');
        if (postLinks.length > 0) {
          postUrl = await page.evaluate(el => el.href, postLinks[0]);
        }
      } catch (urlError1) {
        console.log(`‚ö†Ô∏è L·ªói khi t√¨m URL b√†i ƒëƒÉng (c√°ch 1): ${urlError1.message}`);
      }

      if (!postUrl) {
        try {
          const postLinkHandles = await page.$$('a[href*="/posts/"], a[href*="/permalink/"]');
          if (postLinkHandles.length > 0) {
            postUrl = await page.evaluate(el => el.href, postLinkHandles[0]);
          }
        } catch (urlError2) {
          console.log(`‚ö†Ô∏è L·ªói khi t√¨m URL b√†i ƒëƒÉng (c√°ch 2): ${urlError2.message}`);
        }
      }

      if (!postUrl) {
        try {
          await page.goto(`https://www.facebook.com/profile.php?id=${pageID}`, { waitUntil: "networkidle2" });
          await new Promise(r => setTimeout(r, 3000));
          
          const firstPostLinks = await page.$$('div[role="article"] a[href*="/posts/"], div[role="article"] a[href*="/permalink/"]');
          if (firstPostLinks.length > 0) {
            postUrl = await page.evaluate(el => el.href, firstPostLinks[0]);
          }
        } catch (urlError3) {
          console.log(`‚ö†Ô∏è L·ªói khi t√¨m URL b√†i ƒëƒÉng (c√°ch 3): ${urlError3.message}`);
        }
      }

      let extractedPageId = null;
      let extractedPostId = null;
      let postIdWithPageId = null;

      if (postUrl) {
        const extracted = extractIdsFromPostUrl(postUrl);
        extractedPageId = extracted.pageId;
        extractedPostId = extracted.postId;

        if (extractedPageId && extractedPostId) {
          postIdWithPageId = `${extractedPageId}_${extractedPostId}`;
        } else if (pageID && extractedPostId) {
          postIdWithPageId = `${pageID}_${extractedPostId}`;
        }
      }

      resultList.push({
        requestedPageId: pageID,
        actualPageId: extractedPageId || pageID,
        postId: extractedPostId,
        fullPostId: postIdWithPageId,
        postUrl: postUrl || null
      });

      // Quay v·ªÅ trang qu·∫£n l√Ω Facebook Pages ƒë·ªÉ ti·∫øp t·ª•c v·ªõi trang ti·∫øp theo
      console.log(`üîÑ Quay v·ªÅ trang qu·∫£n l√Ω Facebook Pages...`);
      await page.goto('https://www.facebook.com/pages/?category=your_pages&ref=bookmarks', { 
        waitUntil: "networkidle2",
        timeout: 30000
      });
      await new Promise(r => setTimeout(r, 3000));
    }

    await browser.close();

    res.json({
      success: true,
      message: "üéâ ƒêƒÉng b√†i th√†nh c√¥ng!",
      results: resultList
    });

  } catch (error) {
    console.error("‚ùå L·ªói:", error);
    await browser.close();
    res.status(500).json({
      success: false,
      message: "‚ùó C√≥ l·ªói x·∫£y ra!",
      error: error.message || "Unknown error"
    });
  }
});

app.listen(port, () => {
  console.log(`üöÄ API ƒëang ch·∫°y t·∫°i http://localhost:${port}`);
});
